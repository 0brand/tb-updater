#!/bin/bash

## This file is part of Whonix.
## Copyright (C) 2012 - 2014 Patrick Schleizer <adrelanos@riseup.net>
## See the file COPYING for copying conditions.

#set -x
set -o pipefail
set -o errtrace

SCRIPTNAME="$(basename "$BASH_SOURCE")"
IDENTIFIER="$SCRIPTNAME"

ICON="/usr/share/icons/anon-icon-pack/tbupdate.ico"

## Developer comment on this script:
## I would be very happy if this script would not be required.
## Unfortunately, it is required. It works around a lot bugs:
## - There is no deb/rpm/whatever package with Tor Browser.
##   https://trac.torproject.org/projects/tor/ticket/5236
##   https://trac.torproject.org/projects/tor/ticket/3994
## - There is no way to keep Tor Browser updated.
##   (Thandy doesn't exist yet.)
## - There is no way to add the Documentation page well visible to Tor Browser:
##   https://trac.torproject.org/projects/tor/ticket/6025
##   https://trac.torproject.org/projects/tor/ticket/6053
## - Tor Browsers support for Isolating and Transparent Proxies is very limited:
##   https://trac.torproject.org/projects/tor/ticket/5611
## - tbb-scripts
##   https://github.com/adrelanos/tbb-scripts

tb_error_handler() {
   local exit_code="$?"

   local MSG="<p>###########################################################
<br></br>## $SCRIPTNAME script bug.
<br></br>## No panic. Nothing is broken. Just some rare condition
<br></br>## has been hit. Try again later. There is likely a
<br></br>## solution for this problem. Please see the Whonix News,
<br></br>## Whonix User Help Forum and Whonix Documentation.
<br></br>## <a href=https://www.whonix.org/wiki/Tor_Browser>https://www.whonix.org/wiki/Tor_Browser</a>
<br></br>## Please report this bug!
<br></br>##
<br></br>## BASH_COMMAND: $BASH_COMMAND
<br></br>## exit_code: $exit_code
<br></br>##
<br></br>## output: $output
<br></br>## output_opts: ${output_opts[@]}
<br></br>## progressbaridx: $progressbaridx
<br></br>##
<br></br>## Experts only:
<br></br>## bash -x $SCRIPTNAME
<br></br>###########################################################</p>"

   mkdir --parents ~/".cache/tb"
   echo "$MSG" >> ~/".cache/tb/torbrowser_updater_error.log"

   if [ "$progressbaridx" = "" ]; then
      true
   else
      $output ${output_opts[@]} --progressbaridx "$progressbaridx" --progressx "100" || true
      progressbaridx=""
   fi

   $output ${output_opts[@]} --messagex --titlex "$TITLE" --typex "error" --message "$MSG" --done
   $output ${output_opts[@]} --messagecli --titlecli "$TITLE" --typecli "error" --message "$MSG" --done
   exit 1
}

trap "tb_error_handler" ERR

DOWNLOAD_FAIL_HELP="<p>Possible reasons:</p>
<p>
<br></br>- The download server is down.
<br></br>- File size exceeded (endless data attack triggered).
<br></br>- Tor Browser Updater (by Whonix developers) has been broken due to upstream changes.
</p>
<p>Recommendations:</p>
<p>
<br></br>- Try again later. If the error persists it probably won't solve itself before the next update.
<br></br>- Check News: <a href=https://www.whonix.org/wiki/Download#Stay_tuned>https://www.whonix.org/wiki/Download#Stay_tuned</a>
<br></br>- Manually update: <a href=https://www.whonix.org/wiki/Manually_Updating_Tor_Browser>https://www.whonix.org/wiki/Manually_Updating_Tor_Browser</a>
</p>"

tb_run_function() {
   case $tb_skip_functions in
   *"${1+"$@"}"*) echo "INFO: Skipping ${1+"$@"}, because tb_skip_functions includes it."
                  return 0
                  ;;
   esac

   true "INFO: Running ${1+"$@"}, because tb_skip_functions does not include it."
   eval ${1+"$@"}
}

root_check() {
   if [ "$(id -u)" != "0" ]; then
      #echo "$SCRIPTNAME running as user."
      true
   else
      echo "ERROR: Do not run $SCRIPTNAME as root!"
      exit 2
   fi
}

tb_sanity_tests() {
   command -v id >/dev/null
   command -v basename >/dev/null
   command -v touch >/dev/null
   command -v uname >/dev/null
   command -v mkdir >/dev/null
   command -v pidof >/dev/null
   command -v chmod >/dev/null
   command -v cp >/dev/null
   command -v mv >/dev/null
   command -v killall >/dev/null
   command -v rm >/dev/null
   command -v head >/dev/null
   command -v tar >/dev/null
   command -v date >/dev/null
   command -v /usr/lib/msgcollector/msgcollector >/dev/null
   command -v /usr/lib/msgcollector/pv_wrapper >/dev/null
   ## tbbversion function
   command -v grep >/dev/null
   ## tbbversion function
   command -v sed >/dev/null
   command -v sort >/dev/null
   command -v pv >/dev/null
   command -v mkfifo >/dev/null
}

tb_ex_funct() {
   local MSG
   MSG="$SIGNAL_TYPE received. Cleaning up..."

   if [ "$last_pid_list" = "" ]; then
      true
   else
      for pid in $last_pid_list; do
         kill -1 "$pid"
      done
   fi

   if [ "$progressbaridx" = "" ]; then
      true
   else
      $output ${output_opts[@]} --progressbaridx "$progressbaridx" --progressx "100" || true
      progressbaridx=""
   fi

   $output ${output_opts[@]} --messagecli --typecli "info" --message "$MSG" --done

   #MSG="Aborted."
   #$output ${output_opts[@]} --messagex --typex "error" --message "$MSG" --done
   #$output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG" --done

   MSG="$SIGNAL_TYPE received. Exiting."
   $output ${output_opts[@]} --messagecli --typecli "info" --message "$MSG" --done
}

tb_signal_sigterm() {
   SIGNAL_TYPE="sigterm"
   tb_ex_funct
   exit 143
}

trap "tb_signal_sigterm" SIGTERM

tb_signal_sigint() {
   SIGNAL_TYPE="sigint"
   tb_ex_funct
   exit 130
}

trap "tb_signal_sigint" SIGINT ## ctrl + c

trap_sigusr2() {
   SIGNAL_TYPE="SIGUSR2"
   tb_ex_funct
   exit 3
}

trap "trap_sigusr2" SIGUSR2 ## msgcollector, zenity cancel button

tb_parse_cmd_options() {
   ## Thanks to:
   ## http://mywiki.wooledge.org/BashFAQ/035

   while :
   do
       case $1 in
           --ordinary)
               true "--ordinary enabled, setting CURL_PRGRS to $CURL."
               CURL_PRGRS="$CURL"
               shift
               ;;
           --update)
               true ## legacy
               shift
               ;;
           --noask)
               TB_FORCE_INSTALL="1"
               shift
               ;;
           --nokilltb)
               NOKILLTB="1"
               shift
               ;;
           --devbuildpassthrough)
               TB_FORCE_INSTALL="1"
               DEV_BUILD_PASSTHROUGH="1"
               DEV_PASSTHROUGH="1"
               TB_USE_MSGCOLLECTOR="false"
               shift
               ;;
           ## Keeping --clearnet this for compatibility. Does nothing anymore,
           ## because --clearnet is now the default.
           --clearnet)
               TB_CLEARNET="1"
               shift
               ;;
           --noaskstart)
               noaskstart="true"
               shift
               ;;
           --language)
               TB_LANG="$2"
               shift 2
               ;;
           --no-tor-con-check)
               TB_NO_TOR_CON_CHECK="1"
               shift 1
               ;;
           --alpha)
               TB_VERSIONS_ALPHA="1"
               shift 1
               ;;
           --beta)
               TB_VERSIONS_BETA="1"
               shift 1
               ;;
           --rc)
               TB_VERSIONS_RC="1"
               shift 1
               ;;
           --input)
               TB_INPUT="$2"
               shift 2
               ;;
           --)
               shift
               break
               ;;
           -*)
               echo "$SCRIPTNAME unknown option: $1"
               echo "See:"
               echo "    man $SCRIPTNAME"
               exit 4
               ;;
           *)
               break
               ;;
       esac
   done

   ## If there are input files (for example) that follow the options, they
   ## will remain in the "$@" positional parameters.
   true "$BASH_SOURCE \$@: $@"
}

tb_stdin() {
   if [ ! "$TB_INPUT" = "" ]; then
      output_info_echo_only "INFO: TB_INPUT is already set to $TB_INPUT, skipping auto detection, ok."
      return 0
   fi
   if [ "$TB_FORCE_INSTALL" = "1" ]; then
      output_info_echo_only "INFO: TB_FORCE_INSTALL is set to '1', therefore setting TB_INPUT to 'none'."
      TB_INPUT="none"
      return 0
   fi
   if [ -t "0" ]; then
      output_info_echo_only "INFO: stdin connected to terminal, setting \
TB_INPUT to stdin, will use terminal for input, ok."
      output_info_echo_only "INFO: Alternatively, if want to run from \
command line, but still use the graphical user interface for input, \
you could add to command line: --input gui"
      TB_INPUT="stdin"
      return 0
   fi
   output_info_echo_only "INFO: stdin not connected to terminal, probably run in graphical environment, ok."
}

output_info_echo_only() {
   local MSG
   MSG="${1+"$@"}"
   $output ${output_opts[@]} --messagecli --typecli "info" --message "$MSG" --done
}

output() {
   outputfunc ${1+"$@"}
}

outputfunc() {
   true "$FUNCNAME: args: ${1+$@}"
   if [ "$TB_USE_MSGCOLLECTOR" = "false" ]; then
      while true; do
         case $1 in
            --message)
               local MSG
               MSG="$2"
               shift 2
               break
               ;;
            *)
               break
               ;;
         esac
      done
      MSG="$(/usr/lib/msgcollector/striphtml "$MSG")"
      echo "$MSG"
   elif [ "$outputfunc_verbose" = "true" ]; then
      echo "Running: bash -x $output_tool --identifier $IDENTIFIER --whoami $who_ami ${1+$@}"
      bash -x $output_tool --identifier "$IDENTIFIER" --whoami "$who_ami" ${1+"$@"}
   else
      $output_tool --identifier "$IDENTIFIER" --whoami "$who_ami" ${1+"$@"}
   fi
   true
}

## Make it visible to curl-prgrs.
export -f output
export -f outputfunc

tb_config_folder_parser() {
   for i in /etc/torbrowser.d/*; do
      if [ -f "$i" ]; then
         ## If the last character is a ~, ignore that file,
         ## because it was created by some editor,
         ## which creates backup files.
         if [ "${i: -1}" = "~" ]; then
            continue
         fi
         ## Skipping files such as .dpkg-old and .dpkg-dist.
         if ( echo "$i" | grep -q ".dpkg-" ); then
            true "skip $i"
            continue
         fi
         bash -n "$i"
         source "$i"
      fi
   done
}

tb_preparation() {
   [ -n "$tb_home_folder" ] || tb_home_folder=~/.tb
   [ -n "$tb_cache_folder" ] || tb_cache_folder=~/.cache/tb

   ## Required for /usr/lib/anon-shared-helper-scripts/tor_bootstrap_check.bsh.
   TEMP_DIR="$tb_cache_folder/temp_dir"
   export TEMP_DIR
   rm --recursive --force "$TEMP_DIR"
   mkdir --parents "$TEMP_DIR"

   ## Fortunately, on linux-image-486 kernel, while "uname --all" returns for example
   ## "Linux host 3.2.0-4-486 #1 Debian 3.2.41-2 i686 GNU/Linux",
   ## "uname --machine" returns "i686" and Tor Browser works fine with linux-image-486 kernel.
   ## (There are no 486 downloads for Tor Browser.)
   ##ARCH="x86_64"
   ##ARCH="i686"
   if [ "$ARCH" = "" ]; then
      echo "INFO: Auto detecting ARCH..."
      ARCH="$(uname --machine)"
      echo "INFO: ARCH $ARCH detected."
   else
      echo "INFO: Skipping auto detecting ARCH because already set."
      echo "INFO: ARCH is set to $ARCH."
   fi

   if [ "$ARCH_DOWNLOAD" = "" ]; then
      echo "INFO: Auto detecting ARCH_DOWNLOAD..."
      if [ "$ARCH" = "i386" ]; then
         [ -n "$ARCH_DOWNLOAD" ] || ARCH_DOWNLOAD="linux32"
      elif [ "$ARCH" = "i686" ]; then
         [ -n "$ARCH_DOWNLOAD" ] || ARCH_DOWNLOAD="linux32"
      else
         ## NOTE: A simple else is non-ideal, should there be ever more architectures.
         [ -n "$ARCH_DOWNLOAD" ] || ARCH_DOWNLOAD="linux64"
      fi
      echo "INFO: ARCH_DOWNLOAD $ARCH_DOWNLOAD detected."
   else
      echo "INFO: Skipping auto detecting ARCH_DOWNLOAD because already set."
      echo "INFO: ARCH_DOWNLOAD is set to $ARCH_DOWNLOAD."
   fi

   ## provides tbbversion function
   source /usr/lib/tbbversion_parser

   #echo "INFO: TB_LANG: $TB_LANG"

   ## Check if TB_LANG exists and is not empty.
   if [[ "$TB_LANG" && "${TB_LANG}" ]]; then
      #echo "INFO: Tor Browser language variable is set to "$TB_LANG"."
      true
   else
      #echo "INFO: Tor Browser language variable not found. Setting TB_LANG to the default en-US."
      TB_LANG="en-US"
   fi

   [ -n "$tb_browser_folder" ] || tb_browser_folder="$tb_home_folder/tor-browser_$TB_LANG"

   if [ "$display" = "" ]; then
      if [ "$DISPLAY" = "" ]; then
         display=":0"
      else
         display="$DISPLAY"
      fi
   fi

   if [ "$my_tty" = "" ]; then
      local my_tty_exit_code
      my_tty_exit_code="0"
      my_tty="$(tty)" || { my_tty_exit_code="$?" ; true; };
      if [ ! "$my_tty_exit_code" = "0" ]; then
         my_tty="none"
      fi
      ## Just in case.
      if [ "$my_tty" = "" ]; then
         my_tty="none"
      fi
   fi

   who_ami="$(whoami)"

   TITLE="Tor Browser Updater (by Whonix developers)"

   output_tool="/usr/lib/msgcollector/msgcollector"
   output="output"

   $output --icon "$ICON"
   $output --parenttty "$my_tty"
   $output --whoami "$who_ami"
   $output --titlex "$TITLE"
   $output --titlecli "$TITLE"

   ## Make visible to curl-prgrs.
   export output_tool
   export output
   export IDENTIFIER
   export who_ami

   ret="0"
   command -v curl.anondist-orig >/dev/null || { ret="$?" ; true; };

   if [ "$ret" = "0" ]; then
      ## using the non-uwt-wrapped version, if the uwt wrapper is installed,
      ## which is the case on a default Whonix installation
      CURL=curl.anondist-orig
   else
      ret="0"
      command -v curl >/dev/null || { ret="$?" ; true; };
      if [ "$ret" = "0" ]; then
         ## falling back to real curl, if the uwt wrapper has been uninstalled
         CURL=curl
      else
         local MSG="uwt_tool: Can not find curl. Please report this bug!"
         $output ${output_opts[@]} --messagex --typex "error" --message "$MSG"
         $output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG"
         EXIT_CODE="1"
         return 0
      fi
   fi

   if [ -x /usr/lib/curl-scripts/curl-prgrs ]; then
      ## Curl progress wrapper.
      CURL_PRGRS="/usr/lib/curl-scripts/curl-prgrs"
   else
      true "/usr/lib/curl-scripts/curl-prgrs not available, skipping."
      true "Setting CURL_PRGRS to $CURL."
      CURL_PRGRS="$CURL"
   fi

   ## Debugging CURL_PRGRS.
   #CURL_PRGRS="bash -x /usr/lib/curl-scripts/curl-prgrs"

   ## Debugging / disabling CURL_PRGRS.
   #CURL_PRGRS="$CURL"

   ## Export CURL variable, so it can be read by $CURL_PRGRS.
   export CURL

   mkdir --parents "$tb_home_folder"
   mkdir --parents "$tb_cache_folder"

   ## {{ Download from the torproject.org clearnet by default instead from
   ##    their hidden service.

   [ -n "$TBB_REMOTE_FOLDER" ] || TBB_REMOTE_FOLDER="https://dist.torproject.org/torbrowser"
   [ -n "$CURL_FORCE_SSL" ] || CURL_FORCE_SSL="--tlsv1 --proto =https"

   ## }}

   if [ "$DEV_PASSTHROUGH" = "1" ]; then
      [ -n "$CURL_PROXY" ] || CURL_PROXY=""
   elif [ -d /usr/share/whonix ]; then
      [ -n "$GATEWAY_IP" ] || GATEWAY_IP="10.152.152.10"
      [ -n "$SOCKS_PORT_TBB_DOWNLOAD" ] || SOCKS_PORT_TBB_DOWNLOAD="9115"
      [ -n "$CURL_PROXY" ] || CURL_PROXY="--proxy socks5h://user:password@$GATEWAY_IP:$SOCKS_PORT_TBB_DOWNLOAD"
   else
      [ -n "$CURL_PROXY" ] || CURL_PROXY=""
   fi

   ## Also used by function tbbversion.
   [ -n "$RecommendedTBBVersions" ] || RecommendedTBBVersions="$tb_cache_folder/RecommendedTBBVersions"
}

tb_connectivity_checks_tor() {
   if [ "$DEV_BUILD_PASSTHROUGH" = "1" ]; then
      return 0
   fi

   if [ "$TB_NO_TOR_CON_CHECK" = "1" ]; then
      return 0
   fi

   if [ -x /usr/lib/anon-shared-helper-scripts/tor_enabled_check ]; then
      echo -n "INFO: Running Tor enabled check... "

      source /usr/lib/anon-shared-helper-scripts/tor_enabled_check
      ## sets: TOR_ENABLED
      check_tor_enabled_do

      if [ "$TOR_ENABLED" = "0" ]; then
         MSG="<p><b>Tor not enabled yet.</b></p>

<p>Please check: <blockquote>Start menu -> System -> Whonix Check
              <br></br>or in Terminal: whonixcheck
              <br></br>or in Terminal with debugging: whonixcheck -v</blockquote></p>

<p>Run whonixcheck on Whonix-Gateway as well.</p>

<p>If whonixcheck reports no problems with internet activity and this still fails, please report a bug!</p>

<p>Debugging information:<br />
You could use <code>--no-tor-con-check</code> if you think function <code>$FUNCNAME</code> should be skipped.</p>"

         $output ${output_opts[@]} --messagex --typex "error" --message "$MSG" --done
         $output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG" --done
         exit 5
      fi
      echo "Done."
   else
      true "/usr/lib/anon-shared-helper-scripts/tor_enabled_check does not exist, skipping."
   fi

   if [ -x /usr/lib/anon-shared-helper-scripts/tor_bootstrap_check.bsh ]; then
      echo -n "INFO: Running Tor bootstrap check... "
      source /usr/lib/anon-shared-helper-scripts/tor_bootstrap_check.bsh
      ## sets: tor_bootstrap_percent
      tb_run_function check_tor_bootstrap_helper

      if [ ! "$tor_bootstrap_percent" = "100" ]; then
         MSG="<p></b>Tor not fully bootstrapped.</b></p>

<p>Possible reasons:
<br></br>- no internet connectivity</p>

<p>Please check: <blockquote>Start menu -> System -> Whonix Check
              <br></br>or in Terminal: whonixcheck
              <br></br>or in Terminal with debugging: whonixcheck -v</blockquote></p>

<p>Run whonixcheck on Whonix-Gateway as well.</p>

<p>If whonixcheck reports no problems with internet activity and this still fails, please report a bug!</p>"

         $output ${output_opts[@]} --messagex --typex "error" --message "$MSG" --done
         $output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG" --done
         exit 6
      fi
      echo "Done."
   else
      true "/usr/lib/anon-shared-helper-scripts/tor_bootstrap_check.bsh not available, skipping."
   fi

   true "Tor fully bootstrapped."
}

tb_connectivity_checks_curl() {
   if [ "$DEV_BUILD_PASSTHROUGH" = "1" ]; then
      return 0
   fi

   tb_notify_details="Checking connectivity... Will take a moment..."
   echo "INFO: Running connectivity check... "

   ## 1 MB = 1048576 bytes
   ## 2 MB = 2097152 bytes
   ## Export CURL_PRGRS_MAX_FILE_SIZE_BYTES, so $CURL_PRGRS can read it.
   export CURL_PRGRS_MAX_FILE_SIZE_BYTES="2097152"
   ## Export CURL_OUT_FILE, so $CURL_PRGRS can read it.
   export CURL_OUT_FILE="$tb_cache_folder/tbb_remote_folder"
   curl_download_max_time="180"
   curl_download_target_url="$TBB_REMOTE_FOLDER"
   tb_download_common_exit_on_fail="false"
   tb_download_common

   ## Check if curl failed.
   if [ ! "$curl_exit_code" = "0" ]; then
      MSG="<p>$curl_download_target_url could not be reached.</p>

<p>Possible reasons:
<br></br>- $TBB_REMOTE_FOLDER is down
<br></br>- download location changed</p>

<p>Please check: <blockquote>Start menu -> System -> Whonix Check
              <br></br>or in Terminal: whonixcheck
              <br></br>or in Terminal with debugging: whonixcheck -v</blockquote></p>

<p>If whonixcheck reports no problems with internet activity and this keeps failing, please report a bug!</p>

<p>(Debugging information: curl_status_message: $curl_status_message)</p>"
      $output ${output_opts[@]} --messagex --typex "error" --message "$MSG" --done
      $output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG" --done
      exit 7
   fi

   echo "INFO: Connectivity check succeeded."
}

tb_update_check() {
   ## do not re-download Tor Browser if a previous build already did
   if [ "$DEV_BUILD_PASSTHROUGH" = "1" ]; then
      if [ -d "$tb_browser_folder" ]; then
         echo "$SCRIPTNAME: Not downloading Tor Browser again, because $tb_browser_folder already exists."
         exit 0
      fi
   fi

   [ -n "$TBB_VERSIONS_FILE_LINK" ] || TBB_VERSIONS_FILE_LINK="https://www.torproject.org/projects/torbrowser/RecommendedTBBVersions"

   tb_notify_details="Checking Tor Browser version... Will take a moment..."
   output_info_echo_only "INFO: Find out latest version... Downloading: $TBB_VERSIONS_FILE_LINK... "

   ## 1 MB = 1048576 bytes
   ## 2 MB = 2097152 bytes
   ## Export CURL_PRGRS_MAX_FILE_SIZE_BYTES, so $CURL_PRGRS can read it.
   export CURL_PRGRS_MAX_FILE_SIZE_BYTES="2097152"
   ## Export CURL_OUT_FILE, so $CURL_PRGRS can read it.
   export CURL_OUT_FILE="$RecommendedTBBVersions"
   curl_download_max_time="180"
   curl_download_target_url="$TBB_VERSIONS_FILE_LINK"
   tb_download_common_exit_on_fail="8"
   tb_download_common
}

tb_remote_version_parser() {
   test -f "$RecommendedTBBVersions"

   ## needs: $RecommendedTBBVersions
   ## sets: tbb_recommended_versions_list
   ## sets: tbbversions_found
   ## sets: tbb_recommended_versions_error
   tb_run_function tbbversion
}

tb_remote_version_sanity_test() {
   if [ "$tbb_recommended_versions_list" = "UNKNOWN" ]; then
      local MSG="<p>$installed_or_not_text</p>

<p>Could not find out latest Tor Browser version! $tbb_recommended_versions_error</p>

<p>$DOWNLOAD_FAIL_HELP</p>"
      $output ${output_opts[@]} --messagex --typex "error" --message "$MSG" --done
      $output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG" --done
      exit 9
   fi
}

tb_local_version_detection() {
   ## Used by tbbversion_installed
   [ -n "$tbb_folder" ] || tbb_folder="$tb_browser_folder"

   ## sets: tbb_locally_installed_version
   tb_run_function tbbversion_installed

   if [ -d "$tb_browser_folder" ]; then
      installed_or_not_result="true"
      installed_or_not_text=""
   else
      installed_or_not_result="false"
      installed_or_not_text="Tor Browser is currently not installed.
(Folder $tb_browser_folder does not exist.)"
   fi
}

tb_confirm_update() {
   output_info_echo_only "Currently installed version: $tbb_locally_installed_version"

   if [ "$installed_or_not_result" = "true" ]; then
      local tbb_compare_version
      for tbb_compare_version in $tbb_recommended_versions_list; do
         local dpkg_compare_versions_equals_exit_code="0"
         dpkg --compare-versions "$tbb_compare_version" eq "$tbb_locally_installed_version" || { dpkg_compare_versions_equals_exit_code="$?" ; true; };
         if [ "$dpkg_compare_versions_equals_exit_code" = "0" ]; then
            break
         fi
         local dpkg_compare_versions_greater_than_exit_code="0"
         dpkg --compare-versions "$tbb_compare_version" gt "$tbb_locally_installed_version" || { dpkg_compare_versions_greater_than_exit_code="$?" ; true; };
         if [ "$dpkg_compare_versions_greater_than_exit_code" = "0" ]; then
            break
         fi
         local dpkg_compare_versions_lower_than_exit_code="0"
         dpkg --compare-versions "$tbb_compare_version" lt "$tbb_locally_installed_version" || { dpkg_compare_versions_lower_than_exit_code="$?" ; true; };
         #if [ "$dpkg_compare_versions_lower_than_exit_code" = "0" ]; then
            #break
         #fi
      done
   fi

   local MSG question button type
   button="yesno"
   question="Download now?"

   highest_version_not_always_better_text="\
Only versions still considered secure should be listed here. Higher version numbers does not necessarily mean more secure here. Could be alpha or beta versions. In most cases you are best off choosing the lowest version number among them."

   if [ "$installed_or_not_result" = "true" ]; then
      if [ "$dpkg_compare_versions_equals_exit_code" = "0" ]; then
         up_to_date_or_not_text="Looks like Tor Browser is already up to date."
         re_install_or_install_text="Please close Tor Browser if you want to (re-)install!"
      elif [ "$dpkg_compare_versions_greater_than_exit_code" = "0" ]; then
         up_to_date_or_not_text="Looks like there is an upgrade for Tor Browser."
         re_install_or_install_text="Please close Tor Browser if you want to (re-)install!"
      elif [ "$dpkg_compare_versions_lower_than_exit_code" = "0" ]; then
         up_to_date_or_not_text="<b><u>WARNING: Looks like a downgrade attack!</u></b>"
         re_install_or_install_text="Please close Tor Browser if you want to (re-)install!"
      else
         error "Neither of the following were zero.
<br></br>dpkg_compare_versions_equals_exit_code: $dpkg_compare_versions_equals_exit_code
<br></br>dpkg_compare_versions_lower_than_exit_code: $dpkg_compare_versions_lower_than_exit_code
<br></br>dpkg_compare_versions_greater_than_exit_code: $dpkg_compare_versions_greater_than_exit_code"
         exit 1
      fi
      type="warning"
      MSG="\
<p>$highest_version_not_always_better_text</p>

<p>$up_to_date_or_not_text</p>

<p>$re_install_or_install_text</p>

<p>If your currently installed version is:<blockquote>
   - higher: you are likely target of a downgrade attack, SAY NO NOW.<br></br>
   - equal : only proceed, if you want to create a new browser profile.<br></br>
   - lower : you should upgrade.</blockquote></p>

<p>YOUR BROWSER WILL BE KILLED.<br></br>
YOUR WHOLE BROWSER PROFILE INCLUDING BOOKMARKS AND PASSWORDS WILL GET REPLACED.</p>

<p>A backup of your old Tor Browser and settings will be created in your home folder.
<br></br>It is a good idea to delete old TBB backups once in a while if you are running low with disk space.</p>

<p><a href=https://www.whonix.org/wiki/Tor_Browser/Download_Confirmation_Screen>Learn more about this Download Confirmation Screen.</a></p>"
   else
      type="info"
      MSG="\
<p>$highest_version_not_always_better_text</p>
<p><a href=https://www.whonix.org/wiki/Tor_Browser/Download_Confirmation_Screen>Learn more about this Download Confirmation Screen.</a></p>"
   fi

   $output ${output_opts[@]} --messagecli --typecli "info" --message "$MSG" --done
   output_info_echo_only "https://www.whonix.org/wiki/Tor_Browser/Download_Confirmation_Screen"

   if [ "$TB_INPUT" = "none" ]; then
      answer="$tbb_default_download_version"
   else
      local answer
      if [ "$TB_INPUT" = "stdin" ]; then
         output_info_echo_only "QUESTION: $question
n/${tbb_recommended_versions_slash_separated}?"
         read answer
         if [ "$answer" = "n" ] || [ "$answer" = "" ]; then
            output_info_echo_only "Canceled. Exit."
            exit 10
         fi
      else
         #echo "/usr/lib/msgcollector/tb_updater_gui \"$type\" \"$TITLE\" \"$tbb_locally_installed_version\" \"$tbb_recommended_versions_comma_separated\" \"$MSG\" \"$question\" \"$button\")"
         answer="$("/usr/lib/msgcollector/tb_updater_gui" "$type" "$TITLE" "$tbb_locally_installed_version" "$tbb_recommended_versions_comma_separated" "$MSG" "$question" "$button")"
         if [ "$answer" = "65536" ]; then ## Button 'Yes' has not been pressed.
            output_info_echo_only "Canceled. Exit."
            exit 10
         fi
      fi
   fi
   tbb_version="$answer"
   tbb_version_folder="$answer"
   output_info_echo_only "Version $tbb_version chosen."

   if [ ! "$NOKILLTB" = "1" ]; then
      output_info_echo_only "Because you are not using --nokilltb, now killing eventually still running instances of Tor Browser..."
      killall firefox || true
   fi
}

tb_download_common() {
   if [ "$TB_FORCE_INSTALL" = "1" ]; then
      true
   else
      progressbaridx="$(cat "/proc/sys/kernel/random/uuid")"
      tb_notify_msg="Download
----------------------------------------------------------------------
$tb_notify_details"
      if [ "$TB_INPUT" = "" ] || [ "$TB_INPUT" = "gui" ]; then
         $output ${output_opts[@]} --progressbaridx "$progressbaridx" --progressbarx --parentpid "$$" --typex "info" --progressbartitlex "$TITLE" --message "$tb_notify_msg" --parentpid "$$" --done
      fi
      ## $CURL_PRGRS honors the $CURL and the $CURL_PRGRS_EXEC environment
      ## variables. (See above.)
      ## Define what CURL_PRGRS is supposed to eval.
      ## ($percent is a local variable provided by $CURL_PRGRS.)
      export CURL_PRGRS_EXEC="$output ${output_opts[@]} --progressbaridx "$progressbaridx" --progressx \"\$percent\""
   fi

   ## Simulating endless data attack.
   #export CURL_PRGRS_MAX_FILE_SIZE_BYTES="1048576"

   curl_exit_code="0"
   $CURL_PRGRS \
      --fail \
      $CURL_PROXY \
      $CURL_FORCE_SSL \
      --max-time "$curl_download_max_time" \
      --output "$CURL_OUT_FILE" \
      "$curl_download_target_url" \
      &

   last_pid_list="$!"
   wait "$last_pid_list" || { curl_exit_code="$?" ; true; };
   last_pid_list=""

   if [ "$progressbaridx" = "" ]; then
      true
   else
      $output ${output_opts[@]} --progressbaridx "$progressbaridx" --progressx "100" || true
      progressbaridx=""
   fi

   if [ -x "/usr/lib/curl-scripts/curl_exit_codes" ]; then
      curl_status_message="$(/usr/lib/curl-scripts/curl_exit_codes "$curl_exit_code")" || true
   else
      curl_status_message="$curl_exit_code"
   fi

   if [ "$tb_download_common_exit_on_fail" = "false" ]; then
      true "$FUNCNAME is not supposed to exit, because tb_download_common_exit_on_fail is set to $tb_download_common_exit_on_fail."
      return 0
   fi

   ## Check if curl failed.
   if [ ! "$curl_exit_code" = "0" ]; then
      MSG="<p>Failed to download: $curl_download_target_url</p>

<p>$DOWNLOAD_FAIL_HELP</p>

<p>(Debugging information: curl_status_message: $curl_status_message)</p>"
      $output ${output_opts[@]} --messagex --typex "error" --message "$MSG" --done
      $output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG" --done
      exit "$tb_download_common_exit_on_fail"
   fi

   output_info_echo_only "Done, downloaded $curl_download_target_url."
}

tb_download_files() {
   [ -n "$TBB_EXTRA_FOLDER" ] || TBB_EXTRA_FOLDER="${tbb_version_folder}"

   ### signature ###

   [ -n "$TBB_SIG_FILENAME" ] || TBB_SIG_FILENAME="sha256sums.txt.asc"
   [ -n "$TBB_SIG_LINK" ] || TBB_SIG_LINK="${TBB_REMOTE_FOLDER}/${TBB_EXTRA_FOLDER}/${TBB_SIG_FILENAME}"

   tb_notify_details="Downloading Tor Browser signature... Will take a moment..."
   output_info_echo_only "Downloading GPG signature... Will take a moment..."
   output_info_echo_only "\
Downloading:
      $TBB_SIG_LINK ... Will take a moment..."

   ## 1 MB = 1048576 bytes
   ## 2 MB = 2097152 bytes
   ## Export CURL_PRGRS_MAX_FILE_SIZE_BYTES, so $CURL_PRGRS can read it.
   export CURL_PRGRS_MAX_FILE_SIZE_BYTES="2097152"
   ## Export CURL_OUT_FILE, so $CURL_PRGRS can read it.
   export CURL_OUT_FILE="$tb_cache_folder/$TBB_SIG_FILENAME"
   curl_download_max_time="180"
   curl_download_target_url="$TBB_SIG_LINK"
   tb_download_common_exit_on_fail="8"
   tb_download_common

   ### hash file ###

   [ -n "$TBB_HASH_FILENAME" ] || TBB_HASH_FILENAME="sha256sums.txt"
   [ -n "$TBB_HASH_LINK" ] || TBB_HASH_LINK="${TBB_REMOTE_FOLDER}/${TBB_EXTRA_FOLDER}/${TBB_HASH_FILENAME}"

   tb_notify_details="Downloading Tor Browser sha256sums file... Will take a moment..."
   output_info_echo_only "Downloading sha256sums file... Will take a moment..."
   output_info_echo_only "\
Downloading:
      $TBB_HASH_LINK ... Will take a moment..."

   ## 1 MB = 1048576 bytes
   ## 2 MB = 2097152 bytes
   ## Export CURL_PRGRS_MAX_FILE_SIZE_BYTES, so $CURL_PRGRS can read it.
   export CURL_PRGRS_MAX_FILE_SIZE_BYTES="2097152"
   ## Export CURL_OUT_FILE, so $CURL_PRGRS can read it.
   export CURL_OUT_FILE="$tb_cache_folder/$TBB_HASH_FILENAME"
   curl_download_max_time="180"
   curl_download_target_url="$TBB_HASH_LINK"
   tb_download_common_exit_on_fail="16"
   tb_download_common

   ### archive file ###

   [ -n "$TBB_PACKAGE_FILENAME" ] || TBB_PACKAGE_FILENAME="tor-browser-${ARCH_DOWNLOAD}-${tbb_version}_${TB_LANG}.tar.xz"
   [ -n "$TBB_PACKAGE_LINK" ] || TBB_PACKAGE_LINK="$TBB_REMOTE_FOLDER/${TBB_EXTRA_FOLDER}/$TBB_PACKAGE_FILENAME"

   tb_notify_details="Downloading Tor Browser... Will take a while..."
   output_info_echo_only "Downloading Tor Browser Bundle: $tbb_version"
   output_info_echo_only "\
Downloading:
      $TBB_PACKAGE_LINK ... Will take a while..."

   ## 1 MB = 1048576 bytes
   ## 100 MB = 104857600 bytes
   ## Export CURL_PRGRS_MAX_FILE_SIZE_BYTES, so $CURL_PRGRS can read it.
   export CURL_PRGRS_MAX_FILE_SIZE_BYTES="104857600"
   ## Export CURL_OUT_FILE, so $CURL_PRGRS can read it.
   export CURL_OUT_FILE="$tb_cache_folder/$TBB_PACKAGE_FILENAME"
   curl_download_max_time="3600"
   curl_download_target_url="$TBB_PACKAGE_LINK"
   tb_download_common_exit_on_fail="17"
   tb_download_common

   tb_download_attempt_success="true"
}

tb_gpg_verify() {
   output_info_echo_only "GPG signature verification... This will take a moment..."

   gpg_bash_lib_input_verify_timeout_after="60"
   gpg_bash_lib_input_verify_kill_after="10"
   gpg_bash_lib_input_key_import_dir="/usr/share/torbrowser-updater-keys.d"
   gpg_bash_lib_input_temp_folder="$tb_cache_folder/gpgtmpdir"
   gpg_bash_lib_input_data_file="$tb_cache_folder/$TBB_HASH_FILENAME"
   gpg_bash_lib_input_sig_file="$tb_cache_folder/$TBB_SIG_FILENAME"
   gpg_bash_lib_input_file_name_enforce="false"
   gpg_bash_lib_input_cleanup="false"
   gpg_bash_lib_input_error_handler_extra='tb_error_handler "$gpg_bash_lib_output_error_handler_message"'
   ## One month has 2592000 seconds.
   ## (60 [seconds] * 60 [minutes] * 24 [hours] * 30 [days])
   ## Setting this to 3 months. (777600 seconds)
   ## (2592000 * 3 [months])
   [ -n "$gpg_bash_lib_input_maximum_age_in_seconds" ] || gpg_bash_lib_input_maximum_age_in_seconds="2592000"

   source "/usr/lib/gpg-bash-lib/source_all"

   gpg_bash_lib_function_main_verify

   gpg_bash_lib_output_diagnostic_message="$(/usr/lib/msgcollector/br_add "$gpg_bash_lib_output_diagnostic_message")"

   ## Not checking for gpg_bash_lib_output_alright_status, because then there
   ## would be no way to accept outdated signatures. It is not clear if it is
   ## guaranteed to have a new stable TBB release every three months.
   if [ ! "$gpg_bash_lib_output_validsig_status" = "true" ] || [ "$gpg_bash_lib_output_failure" = "true" ] ; then
      local MSG="<p><b>GPG download signature could NOT be verified.</b>
<br></br>Tor Browser update failed! Try again later.</p>

<p>gpg_bash_lib_output_alright_status: $gpg_bash_lib_output_alright_status
<br></br>gpg_bash_lib_output_failure: $gpg_bash_lib_output_failure</p>

<p>gpg_bash_lib_output_diagnostic_message:</p>

<p>$gpg_bash_lib_output_diagnostic_message</p>"
      $output ${output_opts[@]} --messagex --typex "error" --message "$MSG" --done
      $output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG" --done
      exit 12
   fi

   output_info_echo_only "GPG signature verification ok."
}

tb_hash_verify() {
   output_info_echo_only "Checking hash..."

   rm --force "$tb_cache_folder/sha256_output"

   local first second
   local sha256sum_output sha256sum

   local timeout_after kill_after file_name
   timeout_after="180"
   kill_after="30"

   ## for relative paths
   cd "$tb_cache_folder"

   ## Debugging.
   #timeout_after="0.001"
   #kill_after="0.001"

   tb_sha_exit_code="0"

   timeout --kill-after="$kill_after" "$timeout_after" \
      sha256sum \
         "$TBB_PACKAGE_FILENAME" \
         > "$tb_cache_folder/sha256_output" \
         2>&1 \
         &

   lastpid="$!"
   wait "$lastpid" || { tb_sha_exit_code="$?" ; true; };

   sha256sum_output="$(cat "$tb_cache_folder/sha256_output")" || true

   if grep -q "$sha256sum_output" "$tb_cache_folder/$TBB_HASH_FILENAME" ; then
      output_info_echo_only "Hash check ok."
      return 0
   fi

   output_info_echo_only "Hash check failed! (tb_sha_exit_code: $tb_sha_exit_code) Exiting." >&2
   local MSG="<p><b>Hash could NOT be verified. (tb_sha_exit_code: $tb_sha_exit_code)</b>

<p>$DOWNLOAD_FAIL_HELP</p>"
   $output ${output_opts[@]} --messagex --typex "error" --message "$MSG" --done
   $output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG" --done
   exit 13
}

tb_confirm_install() {
   local MSG question button answer type clock_hint
   local signature_freshness_msg signature_creation_msg
   local last_used_gpg_bash_lib_output_signed_on_date
   local last_used_gpg_bash_lib_output_signed_on_unixtime

   if [ -f "$tb_cache_folder/last_used_gpg_bash_lib_output_signed_on_date" ]; then
      last_used_gpg_bash_lib_output_signed_on_date="$(cat "$tb_cache_folder/last_used_gpg_bash_lib_output_signed_on_date")" || true
   fi
   if [ "$last_used_gpg_bash_lib_output_signed_on_date" = "" ]; then
      last_used_gpg_bash_lib_output_signed_on_date="Unknown. Probably never downloaded a signature before."
   fi
   if [ -f "$tb_cache_folder/last_used_gpg_bash_lib_output_signed_on_unixtime" ]; then
      last_used_gpg_bash_lib_output_signed_on_unixtime="$(cat "$tb_cache_folder/last_used_gpg_bash_lib_output_signed_on_unixtime")" || true
   fi
   if [ "$last_used_gpg_bash_lib_output_signed_on_unixtime" = "" ]; then
      last_used_gpg_bash_lib_output_signed_on_unixtime="unknown"
   fi

   ## Thanks to:
   ## http://mywiki.wooledge.org/BashFAQ/054
   if [[ "$last_used_gpg_bash_lib_output_signed_on_unixtime" != *[!0-9]* ]]; then
      true "'$last_used_gpg_bash_lib_output_signed_on_unixtime' is strictly numeric."
      if [ "$last_used_gpg_bash_lib_output_signed_on_unixtime" -lt "$gpg_bash_lib_output_signed_on_unixtime" ]; then
         signature_freshness_msg="The downloaded signature is newer than the last known signature as expected."
         type="info"
      elif [ "$last_used_gpg_bash_lib_output_signed_on_unixtime" -gt "$gpg_bash_lib_output_signed_on_unixtime" ]; then
         signature_freshness_msg="<b>You are likely target of a downgrade attack</b>, SAY NO NOW! The downloaded signature is older than the last known signature. \
Unless you are downgrading, you should abort now and try again later!"
         type="warning"
      elif [ "$last_used_gpg_bash_lib_output_signed_on_unixtime" = "$gpg_bash_lib_output_signed_on_unixtime" ]; then
         signature_freshness_msg="<b>You could be target of an indefinite freeze attack!</b> The downloaded signature has the same creation date as the last known signature. \
Unless you are re-installing the same version, you should abort now and try again later!"
         type="warning"
      else
         error "last_used_gpg_bash_lib_output_signed_on_unixtime $last_used_gpg_bash_lib_output_signed_on_unixtime \
neither -lt, -gt nor equals gpg_bash_lib_output_signed_on_unixtime $gpg_bash_lib_output_signed_on_unixtime"
         type="error"
      fi
   else
      signature_freshness_msg="We have not previously accepted a signature yet. Therefore assisted check for downgrade \
or indefinite freeze attacks skipped. Please check the Current Signature Creation Date looks sane."
      type="info"
   fi

   if [ -d /usr/share/whonix ]; then
      clock_hint="In that case, please run Timesync: <code>Start menu -> Applications -> System -> Timesync</code>. \
Or in Terminal: <code>timesync</code>."
   fi

   case "$gpg_bash_lib_output_freshness_detail" in
      "lenient")
         signature_creation_msg="<b>Your clock might be slow.</b> $clock_hint
<br></br>
<br></br>According to your system clock, the signature was created $gpg_bash_lib_output_signed_on_unixtime_minus_current_unixtime_pretty before current time.
You can probably ignore this, because it still is within range. (Okay up to $gpg_bash_lib_output_maximum_age_pretty_output before.)"
         ;;
      "slow")
         signature_creation_msg="<b>Your clock might be slow.</b> $clock_hint
<br></br>
<br></br>According to your system clock, the signature was created $gpg_bash_lib_output_signed_on_unixtime_minus_current_unixtime_pretty before current time."
         ;;
      "outdated")
         signature_creation_msg="<b>The signature looks quite old already.</b>
<br></br>
<br></br>Either,
<br></br>- your clock might be fast (at least $gpg_bash_lib_output_in_future_pretty_output fast). $clock_hint
<br></br>- there is really no newer signature yet. The signature is really older than $gpg_bash_lib_output_maximum_age_pretty_output already. (Older than $gpg_bash_lib_output_in_future_pretty_output already.)
<br></br>- this is a $SCRIPTNAME bug
<br></br>- this is an attack"
         ;;
      "current")
         signature_creation_msg="According to your system clock, the signature was created $gpg_bash_lib_output_current_unixtime_minus_signed_on_unixtime_pretty ago."
         ;;
      *)
         error "gpg_bash_lib_output_freshness_detail is neither lenient, nor slow, nor outdated, nor current, it is: $gpg_bash_lib_output_freshness_detail"
         return 0
         ;;
   esac

   gpg_bash_lib_output_gpg_verify_output_br_added="$(/usr/lib/msgcollector/br_add "$gpg_bash_lib_output_gpg_verify_output")"

   MSG="<p><b>Installation confirmation</b></p><p><table><tr>
<td>Currently installed version:</td> <td><tt> $tbb_locally_installed_version</tt></td></tr><tr>
<td>Downloaded version         :</td> <td><tt> $tbb_version</tt></td></tr></table></p>
<p>$signature_freshness_msg</p><p><table><tr>
<td>Previous Signature Creation Date:</td> <td><tt> $last_used_gpg_bash_lib_output_signed_on_date</tt></td></tr><tr>
<td>Last Signature Creation Date    :</td> <td><tt> $gpg_bash_lib_output_signed_on_date</tt></td></tr></table></p>
<p>$signature_creation_msg</p>
<p><u>gpg reports</u>:<br></br>
$gpg_bash_lib_output_gpg_verify_output_br_added</p>
<p><a href=https://www.whonix.org/wiki/Tor_Browser/Installation_Confirmation_Screen>Learn more about this Installation Confirmation Screen.</a></p>"

   $output ${output_opts[@]} --messagecli --typecli "info" --message "$MSG" --done
   output_info_echo_only "https://www.whonix.org/wiki/Tor_Browser/Installation_Confirmation_Screen"

   button="yesno"
   question="Install now?"

   if [ "$TB_INPUT" = "none" ]; then
      true "INFO: TB_INPUT is set to $TB_INPUT, continuing without asking."
   else
      if [ "$TB_INPUT" = "stdin" ]; then
         output_info_echo_only "QUESTION: $question
y/n?"
         read answer
         if [ ! "$answer" = "y" ]; then
            output_info_echo_only "Canceled. Exit."
            exit 14
         fi
      else
         answer="$(/usr/lib/msgcollector/generic_gui_message "$type" "$TITLE" "$MSG" "$question" "$button")"
         if [ ! "$answer" = "16384" ]; then ## Button 'Yes' has not been pressed.
            output_info_echo_only "Canceled. Exit."
            exit 14
         fi
      fi
   fi

   echo "$gpg_bash_lib_output_signed_on_date" > "$tb_cache_folder/last_used_gpg_bash_lib_output_signed_on_date"
   echo "$gpg_bash_lib_output_signed_on_unixtime"  > "$tb_cache_folder/last_used_gpg_bash_lib_output_signed_on_unixtime"
}

tb_extract() {
   if [ "$TB_FORCE_INSTALL" = "1" ]; then
      true
   else
      progressbaridx="$(cat "/proc/sys/kernel/random/uuid")"
      tb_notify_msg="Extraction
----------------------------------------------------------------------
Extracting Tor Browser... This could take a moment..."
      if [ "$TB_INPUT" = "" ] || [ "$TB_INPUT" = "gui" ]; then
         $output ${output_opts[@]} --progressbaridx "$progressbaridx" --progressbarx --parentpid "$$" --typex "info" --progressbartitlex "$TITLE" --message "$tb_notify_msg" --parentpid "$$" --done
      fi
   fi

   local timeout_after kill_after file_name
   timeout_after="180"
   kill_after="30"
   file_name="$tb_cache_folder/$TBB_PACKAGE_FILENAME"

   output_info_echo_only "Extracting $file_name ..."

   ## Debugging.
   #timeout_after="0.001"
   #kill_after="0.001"

   tb_tar_exit_code="0"

   if [ "$TB_FORCE_INSTALL" = "1" ]; then
      timeout --kill-after="$kill_after" "$timeout_after" \
         tar \
            xfv \
            "$file_name" \
            -C "$tb_cache_folder/" \
            &

      lastpid="$!"
      wait "$lastpid" || { tb_tar_exit_code="$?" ; true; };
   else
      pv_echo_command='echo "extraction percent done: "$percent" / 100" >&2'
      pv_wrapper_command="$output ${output_opts[@]} --progressbaridx "$progressbaridx" --progressx \"\$percent\""
      export pv_wrapper_command pv_echo_command

      local tar_fifo tar_pid pv_wrapper_fifo pv_wrapper_fifo
      local pv_exit_code tar_exit_code pv_wrapper_exit_code
      tar_fifo="$TEMP_DIR/tar_fifo"
      pv_wrapper_fifo="$TEMP_DIR/pv_wrapper_fifo"
      pv_exit_code="0"
      tar_exit_code="0"
      pv_wrapper_exit_code="0"

      rm --force "$tar_fifo"
      rm --force "$pv_wrapper_fifo"
      mkfifo "$tar_fifo"
      mkfifo "$pv_wrapper_fifo"

      timeout \
         --kill-after="$kill_after" \
         "$timeout_after" \
            tar \
               xfvJ \
               - \
               -C "$tb_cache_folder/" \
               < "$tar_fifo" &
      tar_pid="$!"
      last_pid_list+=" $tar_pid"

      timeout \
         --kill-after="$kill_after" \
         "$timeout_after" \
            bash \
               /usr/lib/msgcollector/pv_wrapper \
               < "$pv_wrapper_fifo" &
      pv_wrapper_pid="$!"
      last_pid_list+=" $pv_wrapper_pid"

      timeout \
         --kill-after="$kill_after" \
         "$timeout_after" \
            pv \
               -n \
               "$file_name" \
               1> "$tar_fifo" \
               2> "$pv_wrapper_fifo" \
               &
      pv_pid="$!"
      last_pid_list+=" $pv_pid"

      wait "$pv_pid" || { pv_exit_code="$?" ; true; };
      wait "$tar_pid" || { tar_exit_code="$?" ; true; };
      wait "$pv_wrapper_pid" || { pv_wrapper_exit_code="$?" ; true; };

      if [ ! "$pv_exit_code" = "0" ]; then
         tb_tar_exit_code="1"
      fi
      if [ ! "$tar_exit_code" = "0" ]; then
         tb_tar_exit_code="1"
      fi
      if [ ! "$pv_wrapper_exit_code" = "0" ]; then
         tb_tar_exit_code="1"
      fi
   fi

   ## `timeout` returns:
   ## - 124 if sigterm was sufficient
   ## - 137 if needed to use kill.

   if [ "$progressbaridx" = "" ]; then
      true
   else
      $output ${output_opts[@]} --progressbaridx "$progressbaridx" --progressx "100" || true
      progressbaridx=""
   fi

   if [ ! "$tb_tar_exit_code" = "0" ]; then
      local MSG="<p><b>Could not extract $file_name!</b>
<br></br>
<br></br>(Debugging information:
<br></br>tar exit code: $tb_tar_exit_code
<br></br>pv_exit_code: $pv_exit_code
<br></br>tar_exit_code: $tar_exit_code
<br></br>pv_wrapper_exit_code: $pv_wrapper_exit_code)
<br></br>
<br></br>Please report this bug!</p>"
      $output ${output_opts[@]} --messagex --typex "error" --message "$MSG" --done
      $output ${output_opts[@]} --messagecli --typecli "error" --message "$MSG" --done
      exit 15
   fi

   output_info_echo_only "Extraction of $file_name done."
}

tb_patch_version_number_own() {
   ## In past with TBB 3.x the folder ~/"tor-browser_${TB_LANG}/Docs" already
   ## existed. Was later changed. Since TBB's folder structure often changes we
   ## just keep using the folder, create it ourselves and therefore make sure
   ## the script will not break in case of further changes by upstream.
   mkdir --parents "$tb_cache_folder/tor-browser_$TB_LANG/Docs"

   ## Tor Browser changelog has been forgotten to update.
   ## https://sourceforge.net/p/whonix/discussion/general/thread/6122990d/
   ## Later the path was changed from
   ## TBB 3.x ~/"tor-browser_${TB_LANG}/Docs/sources/versions" to
   ## TBB 4.X ~/"tor-browser_${TB_LANG}/Browser/TorBrowser/Docs/sources/versions".
   ## To play it safe and having a chance of finding out the installed version,
   ## we create a file ourselves to remember it.
   output_info_echo_only "Creating version file tor-browser_$TB_LANG/Docs/version."
   echo "$tbb_version" > "$tb_cache_folder/tor-browser_$TB_LANG/Docs/version"
}

tb_patch_download_folder_create() {
   mkdir --parents "$tb_cache_folder/tor-browser_$TB_LANG/Browser/Downloads"
}

tb_patch_internal_updater_disable_maybe() {
   local source_file target_file
   source_file="/usr/share/tb-updater/tb_internal_updater_disable.js"
   target_file="$tb_cache_folder/tor-browser_$TB_LANG/Browser/TorBrowser/Data/Browser/profile.default/preferences/tb_internal_updater_disable.js"

   if dpkg --compare-versions "$tbb_version" ge "4.5" ; then
      output_info_echo_only "No need to deactivate Tor Browser’s Internal \
Updater, because tbb_version $tbb_version is equal or higher than 4.5."
      return 0
   fi

   if [ -f "$source_file" ]; then
      output_info_echo_only "Deactivating Tor Browser’s Internal Updater at least as long \
it does not support verification. See also:
- https://www.whonix.org/blog/tor-browser-updater-warning
- https://www.whonix.org/forum/index.php/topic,807
Feel free to delete file
$target_file
if you want to disable this behavior.
To permanently disable this $SCRIPTNAME feature, create a file
/etc/torbrowser.d/50_user
and add:
tb_skip_functions+=\" $FUNCNAME \""
      cp "$source_file" "$target_file"
   else
      output_info_echo_only "Not Deactivating Tor Browser’s Internal Updater because file
$source_file
does not exist."
   fi
}

tb_patch() {
   tb_run_function tb_patch_version_number_own
   tb_run_function tb_patch_download_folder_create
   tb_run_function tb_patch_internal_updater_disable_maybe
}

tb_install() {
   if [ -d "$tb_browser_folder" ]; then
      output_info_echo_only "Moving old folder $tb_browser_folder..."
      mv "$tb_browser_folder" "$tb_browser_folder.old.$(date '+%F-%H:%M:%S')"
   fi

   output_info_echo_only "Moving temporary folder $tb_cache_folder/tor-browser_$TB_LANG to $tb_browser_folder."
   mv "$tb_cache_folder/tor-browser_$TB_LANG" "$tb_browser_folder"
}

tb_end() {
   local TEMP
   TEMP="$tb_browser_folder"

   if [ "$TB_FORCE_INSTALL" = "1" ]; then
      output_info_echo_only "Finished installing Tor Browser. Can be found in $TEMP."
      output_info_echo_only "Not starting Tor Browser, because variable TB_FORCE_INSTALL is set to 1."
      return 0
   fi

   local command_v_torbrowser_exit_code="0"
   command -v torbrowser || { command_v_torbrowser_exit_code="$?" ; true; };

   if [ "$command_v_torbrowser_exit_code" = "0" ]; then
      if [ "$noaskstart" = "true" ]; then
         output_info_echo_only "noaskstart is set to true. Skipping question if Tor Browser should be started."
      else
         MSG="<p>Finished installing Tor Browser. Can be found in $TEMP.</p>

<p>Please donate!
<br></br><a href=https://www.whonix.org/wiki/Donate>https://www.whonix.org/wiki/Donate</a></p>"
         local question="Start Tor Browser?"
         local button="yesno"
         local answer
         if [ "$TB_INPUT" = "none" ]; then
            true "INFO: TB_INPUT is set to $TB_INPUT. Skipping question if Tor Browser should be started."
         elif [ "$TB_INPUT" = "stdin" ]; then
            output_info_echo_only "QUESTION: $question
y/n?"
            read answer
            if [ ! "$answer" = "y" ]; then
               output_info_echo_only "Canceled starting Tor Browser, ok."
            else
               torbrowser
            fi
         else
            answer="$(/usr/lib/msgcollector/generic_gui_message "info" "$TITLE" "$MSG" "$question" "$button")"
            if [ ! "$answer" = "16384" ]; then ## Button 'Yes' has not been pressed.
               output_info_echo_only "Canceled starting Tor Browser, ok."
            else
               torbrowser
            fi
         fi
      fi
   else
      output_info_echo_only "torbrowser binary not found in path. tb-starter is probably not installed. \
Skipping question to start Tor Browser."
   fi
}

tb_sort_remote_versions() {
   if [ "$tbb_recommended_versions_list" = "" ]; then
      error "tbb_recommended_versions_list was empty before sorting."
   fi

   ## Example tbb_recommended_versions_list:
   ## 2.3.25-16 3.8 2.6 3.7 3.1 3.1 3.4 2.3.25-15 3.5

   rm --force "$TEMP_DIR/tbb_recommended_versions_list"
   touch "$TEMP_DIR/tbb_recommended_versions_list"
   test -f "$TEMP_DIR/tbb_recommended_versions_list"
   local tbb_sort_version
   for tbb_sort_version in $tbb_recommended_versions_list; do
      echo "$tbb_sort_version" >> "$TEMP_DIR/tbb_recommended_versions_list"
   done

   tbb_recommended_versions_list="$(sort --unique --version-sort "$TEMP_DIR/tbb_recommended_versions_list")"
   if [ "$tbb_recommended_versions_list" = "" ]; then
      error "tbb_recommended_versions_list is empty after sorting."
   fi

   ## Example tbb_recommended_versions_list:
   ## 3.8
   ## 3.7
   ## 3.5
   ## 3.4
   ## 3.1
   ## #2.6
   ## 2.3.25-16
   ## 2.3.25-15

   ## Choose lowest version number for default file download. Only used for TB_FORCE_INSTALL.
   read -r tbb_default_download_version _ <<< "$tbb_recommended_versions_list"

   ## Thanks to:
   ## https://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-bash-variable/3352015#3352015
   ## for the leading/trailing whitespace removal code

   local temp
   temp="${tbb_recommended_versions_list//$'\n'/,}"
   temp="${temp#"${temp%%[![:space:]]*}"}" ## remove leading whitespace characters
   temp="${temp%"${temp##*[![:space:]]}"}" ## remove trailing whitespace characters
   tbb_recommended_versions_comma_separated="$temp"

   temp="${tbb_recommended_versions_list//$'\n'//}"
   temp="${temp#"${temp%%[![:space:]]*}"}" ## remove leading whitespace characters
   temp="${temp%"${temp##*[![:space:]]}"}" ## remove trailing whitespace characters
   tbb_recommended_versions_slash_separated="$temp"
}

main_function() {
   tb_run_function root_check
   tb_run_function tb_sanity_tests
   tb_run_function tb_config_folder_parser
   tb_run_function tb_parse_cmd_options ${1+"$@"}
   tb_run_function tb_preparation
   tb_run_function tb_stdin
   tb_run_function tb_local_version_detection
   tb_run_function tb_connectivity_checks_tor
   tb_run_function tb_connectivity_checks_curl
   tb_run_function tb_update_check
   tb_run_function tb_remote_version_parser
   tb_run_function tb_remote_version_sanity_test

   ## For testing:
   #tbb_recommended_versions_list="2.3.25-16 3.8 2.6 3.7 3.1 3.1 3.4 2.3.25-15 3.5"
   #tbb_recommended_versions_list="2.3.25-16 2.3.25-15 $tbb_recommended_versions_list 10.0 15.0 20.0 25.0 30.0"

   tb_run_function tb_sort_remote_versions
   tb_run_function tb_confirm_update
   tb_run_function tb_download_files
   tb_run_function tb_gpg_verify
   tb_run_function tb_hash_verify
   tb_run_function tb_confirm_install
   tb_run_function tb_extract
   tb_run_function tb_patch
   tb_run_function tb_install
   tb_run_function tb_end
}

tb_run_function main_function ${1+"$@"}
